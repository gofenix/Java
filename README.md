# Java
自己整理的java面试题

1. **java中的几种基本数据类型是什么，各自占了多少字节。**

   - 逻辑型

     boolean

   - 文本型

     char

   - 整数型

     byte short int long

   - 浮点型

     float double

   |   类型    |             字节数             |
   | :-----: | :-------------------------: |
   | boolean |    待定（java虚拟机规范写的是4个字节）     |
   |  char   | 2（java是unicode编码，一个字符占2个字节） |
   |  byte   |              1              |
   |  short  |              2              |
   |   int   |              4              |
   |  long   |              8              |
   |  float  |              4              |
   | double  |              8              |

2. **Java中是否可以继承String类，为什么？**

   不可以。String类有final修饰符。

3. **String，Stringbuffer，StringBuilder的区别**

   String：字符串常量，不可变的对象

   StringBuffer：字符串变量（线程安全）

   StringBuilder：字符串变量（非线程安全）

   一般情况下执性速度：StringBuilder>StringBuffer>String

4. **ArrayList 和 LinkedList 有什么区别？**

   - ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 
   - 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 
   - 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 

5. **讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候，他们的执行顺序。**

   - 虚拟机在首次加载Java类时，会对静态初始化块、静态成员变量、静态方法(这三种统称为静态代码块)进行一次初始化 。
   - 类实例创建过程：按照父子继承关系进行初始化，首先执行父类的初始化块部分，然后是父类的构造方法；再执行本类继承的子类的初始化块，最后是子类的构造方法 。
   - 类实例销毁时候，首先销毁子类部分，再销毁父类部分。

   new一个对象时，执行过程如下：

   默认初始化（对成员赋0或NULL）—>进构造函数—>super()【父类也是该过程】—>显式初始化—>构造代码块—>构造函数中其它代码

6. **用过哪些 Map 类，都有什么区别。HashMap 是线程安全的吗？并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。**

   - HashMap

     - 数据结构

       HashMap底层实现还是数组，只是数组的每一项都是一条链。每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值。

     - 默认容量

       初始容量16，默认加载因子0.75。容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度。

     - 存储过程

       HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。

     - 扩容

       该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。

   - HashTable

     类似HashMap。还是有一些不同的：

     - HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。
     - HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。

   - TreeMap

     TreeMap的实现是红黑树算法的实现。

     红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：

     - 每个节点都只能是红色或者黑色
     - 根节点是黑色
     - 每个叶节点（NIL节点，空节点）是黑色的。
     - 如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。
     - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

   - hashcode

     - hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
     - 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
     - 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
     - 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

   HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环，一旦成环，Entry的next节点永远不为空，就会产生死循环。

   Hashtable是Java中最老的Map类，它是一个线程安全的Map类，其公有方法均使用synchronize关键字修饰,这表示在多线程操作时，每个线程在操作之前都会锁住整个map，待操作完成后才释放，如线程1使用put进行元素添加,线程2不但不能使用put方法进行添加元素,也不能使用get方法来获取元素,所以竞争越激烈效率越低，这必然导致多线程时性能不佳。另外，Hashtable不能使用null作为key或者value。

   ConcurrentHashMap的锁分段技术可有效提升并发访问率 。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

7. **JAVA8 的 ConcurrentHashMap 为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。**

   取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。

   将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。


8. **有没有有顺序的 Map 实现类，如果有，他们是怎么保证有序的。**

   TreeMap：可以指定排序函数，但不是按照插入顺序排序的。内部是红黑树的存储，可以实现排序。

   LinkedHashMap：内部有一个链表，保持插入的顺序。迭代的时候，也是按照插入顺序迭代，而且迭代比HashMap快。

9. **抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。**

   - 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
   - 抽象类要被子类继承，接口要被类实现。
   - 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。
   - 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
   - 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
   - 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
   - 抽象类里可以没有抽象方法
   - 如果一个类里有抽象方法，那么这个类只能是抽象类
   - 抽象方法要被实现，所以不能是静态的，也不能是私有的。
   - 接口可继承接口，并可多继承接口，但类只能单根继承。

10. **继承和聚合的区别。**

    - 如果新的类只是使用老的类的一部分功能，那么就是用聚合，直接new出来就可以了，满足need或者组合这个关系；
    - 如果新的类必须是老的类的一个特殊例子，那么就是用继承，满足is-a或者is-like-a这种关系。

    继承

    指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 

    实现

    指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性； 

    依赖

    可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用； 

    关联

    他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量； 

    聚合

    聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 

    组合

    组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 

11. **谈谈nio的理解**

    阻塞I/O在调用InputStream.read()方法时是阻塞的，它会一直等到数据到来时（或超时）才会返回；同样，在调用ServerSocket.accept()方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。阻塞I/O通信模型，有两点缺点：

    - 当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些CPU时间。
    - 阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。

    java NIO的工作原理：

    - 由一个专门的线程来处理所有的 IO 事件，并负责分发。
    - 事件驱动机制：事件到的时候触发，而不是同步的去监视事件。
    - 线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。

    java NIO采用了双向通道（channel）进行数据传输，而不是单向的流（stream），在通道上可以注册我们感兴趣的事件。比如：

    | 事件名          | 对应值                        |
    | ------------ | -------------------------- |
    | 服务端接收客户端连接事件 | SelectionKey.OP_ACCEPT(16) |
    | 客户端连接服务端事件   | SelectionKey.OP_CONNECT(8) |
    | 读事件          | SelectionKey.OP_READ(1)    |
    | 写事件          | SelectionKey.OP_WRITE(4)   |

    服务端和客户端各自维护一个管理通道的对象，我们称之为selector，该对象能检测一个或多个通道 (channel) 上的事件。我们以服务端为例，如果服务端的selector上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞I/O这时会调用read()方法阻塞地读取数据，而NIO的服务端会在selector中添加一个读事件。服务端的处理线程会轮询地访问selector，如果访问selector时发现有感兴趣的事件到达，则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。

12. **反射的原理，反射创建类实例的三种方式是什么。**

    指在运行状态中，对于任意一个类,都能够知道这个类的所有属性和方法；对于任意一个对象,都能调用它的任意一个方法。这种动态获取信息，以及动态调用对象方法的功能叫java语言的反射机制。

    - 创建Class对象的方式一：(对象.getClass())
    - 创建Class对象的方式二：(类.class:需要输入一个明确的类)
    - 创建Class对象的方式三：(forName():传入时只需要以字符串的方式传入即可)。Class.forName()有异常：ClassNotFoundException

13. **反射中，Class.forName 和 ClassLoader 区别。**

    java中class.forName和classLoader都可用来对类进行加载。前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。

    而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。

    Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法才去调用构造函数，创建类的对象 。

14. **描述动态代理的几种实现方式，分别说出相应的优缺点。**

    静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 
    动态代理：在程序运行时，运用反射机制动态创建而成。 

    动态代理有两种方式：

    - jdk方式

      委托类必须实现接口，代理类只能对接口进行代理。使用java的反射机制，以及Proxy和InvocationHandler来实现，代理类与委托类实现了相同的接口。 


    - cglib

      code generate library，代理类可对类进行代理，使用第三方cglib库来实现，其内部使用asm框架生成代理类的字节码，其字节码文件更加复杂，不能代理final方法，因为代理类是委托类的子类。 

    cglib生成的代理类的运行性能比jdk更加优秀，但是生成对象的时间更长，在单例模式中可以使用cglib，在频繁创建对象的模式中建议使用jdk。

15. **动态代理与 cglib 实现的区别。**

    参上。

16. **为什么 CGlib 方式可以对没有接口的类实现代理。**

    CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。

17. **final的用途。**

    - final修饰类：

      被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改，Java的一些核心的API都是final类，例如String、Integer、Math等。

    - final修饰方法：

      子类不可以重写父类中被final修饰的方法。

    - final修饰实例变量(类的属性，定义在类内，但是在类内的方法之外)：
      final修饰实例变量时必须初始化，且不可再修改。

    - final修饰局部变量(方法体内的变量)：

      final修饰局部变量时只能初始化(赋值)一次，但也可以不初始化。

    - final修饰方法参数
      final修饰方法参数时，是在调用方法传递参数时候初始化的。

18. 写出三种单例模式实现。

    - 延迟加载——不考虑效率问题的延迟加载

      ```java
      public class SingleTon{
          private static SingleTon instance = null;
          public static synchronized SingleTon getInstance(){
              if(instance==null){
                  instance = new SingleTon();
              }
          }
      }
      ```

      ​

    - 即时加载的基本实现

      ```java
      public class SingleTon(){
          private static SingleTon instance = new SingleTon();
          public static SingleTon getInstance(){
              return instance;
          }
      }
      ```

      ​

    - Double Check方式——关键考虑在于并发环境下返回结果的性能提升能否抵消多出来的两次判断跳转

      ```java
      public class SingleTon{
          private volatile static  SingleTon uniqueInstance;
          private SingleTon(){}
          public static SingleTon getInstance(){
              if(uniqueInstance==null){
                  synchronized(SingleTon.class){
                      if(uniqueInstance == null){
                          uniqueInstance = new SingleTon();
                      }
                  }
              }
              return uniqueInstance;
          }
      }
      ```

19. ​

